1) The Semaphore solution avoids starvation by verifying if there are mice waiting when two cats have gone, and then allows the mice to go into the kitchen before any more cats are allowed to. If there are no mice in waiting, then two more cats are allowed to go in. This gives mice priority and keeps them from suffering of starvation. After two mice have ate in the kitchen, then two cats are allowed into the kitchen, thus allowing cats and mice to take turns eating, and avoiding starvation for both animals. The lock solution avoids starvation. If there are mice waiting to enter the kitchen, and two cats have already gone in the turn for cats, then they are allowed into the kitchen IF there are currently no cats in the kitchen, giving mice priority over cats. If 2 mice have went this turn, then the cats are allowed back into the kitchen again. Additionally, as long as there are no mice waiting they can remain in the kitchen to eat, but when mice are beginning to be in wait again, they are given priority, therefore all cats must wait until the mice have ate before being allowed back into the kitchen.

2) After finishing this particular problem, we see that they could both be used in many ways to solve a plethora of synch. problems. We see the pros and cons of cv's and lock and a semaphore implementation. For one, when you want to signal more than one resource that is available for a semaphore implementation, you have to signal two different times instead of just setting the lock count to the specific number like you can with locks and conditional variables.

We have implemented this to control the number of mice or cats allowed to
eat in their own turn. The conditional variable implementation is better suited for waiting on certain conditions instead of waiting to acquire the lock compared to in a semaphore implementation, it is better suited in a scenario where you are just waiting on a resource, whereas conditional variables seem better for allowing conditions to be met while you are in wait, since you can repeatedly call cv_wait() where you can only call wait(() for a semaphore once at a time as otherwise, you would decrement your semaphore counter continuously, and no one would ever have a chance to go eat. Both of these synchronization philosophies can be used to solve the same problem, but both have their own individual advantages that make them useful in certain situations or in their own ways comparatively. 
